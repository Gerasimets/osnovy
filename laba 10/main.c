#pragma warning(disable : 4996)
#include <stdio.h>
#include <string.h>
#include <malloc.h>
// Скопировать текстовый файл, зеркально поменяв порядок слов.
#define N 30

void main(void) {

	FILE* fpin = fopen("C:\\Users\\User\\source\\repos\\file.txt", "rt"); // открыть входной файл для чтения
	FILE* fpout = fopen("C:\\Users\\User\\source\\repos\\result.txt", "wt"); // открыть файл для записи
	char line[N];// массив для считывания строки
	char *buffer = NULL; // используется для динамической строки/массива
	char** lines = NULL; // указатель на динамический двумерный массив
	char *begin = NULL; // указатель на начало слова, но читаем мы с конца строчку
	char* end = NULL; // указатель на конец слова, но читаем мы с конца строчку
	char* t = NULL; //указатель временный, чтобы сохранить позицию при переписывании из line в buffer
	int i = 0; //нужен, чтобы грамотно идти по индиксам при обработке строки line, по сути просто длина_строки-1
	int lsize = 0; //длина очередной строки
	int k = 0; //счетчик строк для заказа новой памяти
	int j; //индекс для buffer
	int flag = 0; //флаг состояний
	//нет лишних пробелов и нет лишних строк
	while (!feof(fpin)) // цикл до конца входного файла
	{
		k++; // счетчик нужного количества строк
		j = 0;
		fgets(line, N, fpin); // считываем очередную строку
		lsize = strlen(line);// узнаем длину строки
		i = lsize - 1; // берем правильные индексы (Количество -1 = последний индекс)
		if (line[i] != '\n') // для последней строки
		{
			i++;
			lsize++;
			line[i] = '\n';
			line[i + 1] = '\0';
		}

		buffer = (char*)malloc(lsize + 1); // заказ нужного количества памяти в массиве BUFFER (количество символов +1 на '\0')
		begin = &line[i]; // указываем начало на самый конец строки, так как i - индекс последенего элемента
		do // идем от конца к началу
		{
			if (lsize == 1)
			{
				break;
			}

			i--;//индекс смещения по массиву строки
			if (line[i] == ' ') //если у нас пробел, то запоминаем его как конец и флаг =2 (означает,что конец найден, можно копировать)
			{
				end = &line[i] + 1;//указатель конца слова теперь указывает на пробел
				flag = 2;//означает, что нашли конец, тепеь готовы удалять
			}

			if (&line[i] == &line[0]) // особывй случай, последний - начало строки, там нет пробела, поэтому назначим end самостоятельно
			{
				end = &line[i]; // указатель конца слова теперь указывает на первый символ, так как пробела в этом случае нет
				flag = 2; // означает, что нашли конец, тепеь готовы удалять
			}

			if (flag == 2) //копирвание
			{
				flag = 0; //опускаем флаг для след слова
				t = *&end; //запоминаем позицию последнего end, чтобы после его считать началом след слова
				while (end != begin)
				{
					buffer[j] = *end;
					end++;//просто копирование со сдвигом
					j++;
					if ((end == begin) && (*begin) == '\n')
					{
						buffer[j] = ' ';
						j++;
					}
				}
				begin = *&t; //присваиваем началу тот самый пробел, что запомнили
			}
		} while (i != 0);// как дойдем до первого элемента line - выйдем

		buffer[lsize] = '\0'; // для красоты
		buffer[lsize - 1] = '\n';
		lines = (char**)realloc(lines, k * sizeof(char*)); // заказать динамический массив указателей c выделением памяти
		lines[k - 1] = (char*)malloc(sizeof(char) * (lsize + 1)); // заказать в памяти место для строки плюс один байт
		strcpy(lines[k - 1], buffer); // копируем. Очищаем буфер (buffer)
		free(buffer);
	}
	fclose(fpin); // вывод

	for (int i = 0; i < k; i++)
	{
		fputs(lines[i], fpout);
		free(lines[i]);
		lines[i] = NULL;
	}
	free(lines);
	lines = NULL;
}
